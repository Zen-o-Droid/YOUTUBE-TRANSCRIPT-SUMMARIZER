English Transcript:
So when i say waterfall you can think about something like you know a banking application or insurance application or some police department application so the moment i say waterfall model you can think of like a really huge application which is you know made up of small chunks of code for example this application might have a front-end this application would obviously have a back-end and then it has some dns routes and a few services that it's dependent on so it doesn't really matter how many services are part of this application but this entire application was shipped as a one-hole application that's how they used to happen back in the day and this was referred to or this method of development the waterfall method the application was referred to as a monolithic application now it's called monolithic if i can write it properly monolithic application now you know everything was fine in d&d unless like two thousands 2002 and that's when things started to become a bit extreme because the clients would have ten different requirements that would change almost every day now if you have one single application you have a single point of failure so if we were changing even this limb part of this application and if this part was to fail this entire application would stop working that's when people started brainstorming about better approaches to software development and how can you meet the requirements of the millennium of the today's world - without actually affecting how the software is written or any application is written in the first place that's where the ideas of agile development came into the picture so that was one part of the problem the second part of the problem was because it was a monolithic application the time that it required to actually push the changes for example let's say you have an application up and running in your production environment and your development team actually created a new feature or they modify the existing feature now that feature is supposed to go in production Second part of the problem that people were trying to solve that's when agile came into the picture now agile put in simple terms is a philosophy to rapidly deploy an application in much more organized way now obviously there is a lot more details than meets the eye but in a simple sentence that's what you mean by a jar you want rapid deployment of the software or the code that you writing without having to wait for a longer time at the same time you want to make sure that you have small chunks of code that can be shipped to the client or whichever application you're working with that's the reason rajal exists today and now we're going to look at what do you mean by agile and how can you actually implement this. So this is what has been happening for the past four decades but this won't really fly in today's world because there are multiple changes being pushed every single day so you can't really just go through the months of planning for a little change so the way applications are developed have changed and so is the way applications are deployed so that's what you mean by waterfall models now i think i have explained it pretty well there are a lot of companies that still follow this model but at the end of the day all of them are trying to you know migrate to a more agile development it's not so easy depending on the size of the company. And you review it if you notice launch is actually outside of this entire circle meaning every time you make a change it could be something as simple as just one line of code change just available being renamed so it doesn't matter how small or how big the changes the idea is the moment the change is made it has to be deployed even in a dev environment so that you can get a constant feedback over what's happening with the code that you have imagine if you actually had to wait for one month or two weeks just to get the feedback on if you really want that change or not now that could be a little annoying or frustrating from the developers point of view Right i'm not saying change your entire application what i'm saying is the model is pretty much people centric the people like the development team and the customers and the end users are given more importance and working software over comprehensive documentation now this is something that all of us would have noticed at some point in time right so every application would have an internal document of how long 100 pages 150 pages about all the class all the methods how the application is being built then why the application is being built who's the owner in like plethora of other details that you as an individual is not even concerned about you are concerned about what you have to build and how far along are you in that development task so in agile the functional application is given much more importance than the documentation because if you think about it the code itself is a documentation right if you knew how to interpret the code you could look at the code and that can also act as an documentation so i'm not saying that won't be any documentation all i'm saying is the development is given more importance over the documentation part. And then it's going to take you to something called a shopping cart and after you made the payments and all those things you have email notifications and you know text notifications the point here is even though all of these things are working in synergy they are actually completely separate services completely separate tasks in the underlying architecture so if i am working on something on the front end i don't really have to be worried about the catalogs and the shopping because first i am getting a constant feedback even before the launch i am getting a feedback about what's gonna happen once we launch your code to the production at the same time i don't really have to be afraid that it's gonna break my entire application because all of them are developed as separate micro-services your one service will never affect another service of course the dependent services might be affected but the idea is you never really want a single point of failure that's the idea of a jar now let's move forward now what are the terms and the values of our job And then customer collaboration over rigid contracts and responding to change rather than following the plan so agile is really feedback dependent meaning back in the day you know the managers and the product owners will have multiple meetings they'll come up with the kind of software that they bought everything would be discussed over like three four months and then people would want to stick to the plan because you already spent four months planning this thing now if you wanted to change even a little part of this the entire meetings and planning would have to be done all over again now agile changes that agile works more on the feedback just because the plan has been made it does not mean that cannot be any changes because you've broken things down into smaller chunk of tasks any one of the tasks can be modified according to the requirements at any point in time so these are the values that agile bring to the table. But that's not really the case we are actually going to look at how all of this materializes like you know over the future slides when we actually talk about how can you implement a job in the working or the team that you're working with so let's more now advantages of agile do you pretty much kind of you know touched upon all of these things for now persistence software delivery increased stakeholder satisfaction inspect and adapt welcome to changes at any stage design is important and daily interactions now comes the meat of the entire presentation now you have a basic idea of persia right but question that everybody has at any point in time is what's in it for me. And then they kind of have their own philosophy that works for their organization but scrum is the one that's used by the majority of the people so even before looking at the slide you know before we go through what we see in the slide i can just kind of explain scrumpy you the way i know it right because i worked with multiple development teams i've seen most of these being implemented and i know how each one of them work in the real world example so what is scrum so scrum is basically an iterative philosophy meaning you i trade over the changes you i trade over the deployments and software Development one at a time so if you wanted to talk about scrum scrum is an iteration of plan then build then cass and then review now you would constantly be iterating over all of these aspects now what do i even mean by this so let's first look at how or what does a scrum implemented team looks like so in scrum implemented team you have the very first person that i want to talk about someone corners product owner now when i say product owner if you're coming from you know more of a traditional software development environment you can think of a product owner as a manager he is the guy who holds the responsibility to make sure that the application is deployed as and when committed at the same time the application is built exactly as the way it has to be built so product owner is the guy with the ideas he might not necessarily be a technical person he might as well be a guy from the management he does not necessarily have to know the development or the technicalities in detail he's the guy with the idea and the owner of the application that would be developed so pretty much all the accountability lies on him and then there is someone called a scrum master now scrum master is someone that you would have traditionally referred to as a team leader or a project owner now you can think about scrum master as a team leader in the hierarchical sense this is the person that's right below the product owner and this is the person who actually does the data or handles the day-to-day operations like you know running the meetings or handing the tasks that have to be done and then you have the team itself which will consist of your developers and testers and you know depending on your requirement it might have a few more roles but then you have the actual team but we'll execute the tasks so these are the three roles that you have but now that we know the people that are involved how exactly this works i mean this looks pretty much similar to what you do at your office it's just fancy names. So how is it any different from what you do at your office so that's what we want to look at now i hope the roles are kind of clear to you now that you have the roles defined let's look at the first thing about the development so the first part of the development that we want to look at it's called product backlogs now here's where things start to get a bit different from how you might have been working at a traditional environment now in a traditional environment you have an application that has been already planned for months and you along with others have been working on deploying the application But i hope you realize it's called sprint now there are different you could call them ceremonies or rituals but there is something called a sprint planning now the sprint planning again it's just a fancy name for the makings and discussions that you have during the sprint planning the product owner will actually explain how he imagines the end goal or the product for the application to look like so you have something called a sprint planning you have something called its daily scrum now daily scrum is nothing more than you know the 15 minutes meeting that happens every day where the developers and the testers and any other role that you have in the game can actually discuss what happened and where you stand if you need any help there any blockades and what do you plan to do today or tomorrow and then there is something called a sprint review so sprint review actually occurs at the end of the user story or the battle that you've been working on so each and every one of these user stories right they usually are designed with the timeline of two weeks in mind now some companies the sprint's may vary like it could be two weeks to four weeks but in majority of the cases each sprint will last two weeks so that you know exactly what you're supposed to do for the next two weeks now at the end of the two weeks along with you know you're planning your daily meetings once your sprint is completed you have a sprint review. So logically i would want to prioritize my front-end over my payment processor so scrum master and product owner will prioritize the user stories that you have and depending on the priorities that has been said they come up with something called a sprint backlog now spread backlog is when your development team actually gets involved in this because now you already have an organized and prioritized user stories that you are supposed to be working on so ten different things are not just dumped on you at the same time you are given a logical and reasonable tasks that have to be executed one at a time and once he has a sprint backlog you can actually start working on it as a development now i'll get rid of this beautiful drawing that are made for now then let's just look at now a sprint backlog But you know that the part is ready to be assembled into the application that you have so the idea is at the end of every two weeks you have a shippable part of the application that is ready to be deployed so instead of working a huge application that would have taken a year anyway now you kind of break it down into things that can be actually shipped in two weeks depending on the priorities that have been set by the product owner and the scrum master that you have that's the idea of scrum to break everything down into smaller chunks of coal smaller chunks of tasks so that everyone knows exactly what they're supposed to do that's like the methodical part of it right you have a method there is a specific best set of practices that you following along with the technical side because you have a rapid deployment the moment you write a code you can actually test it in the dev environment now that's where people like me devops come into the picture. But the idea is you don't really have to wait for a month just to see what you code it right now if you push the code right now in matter of minutes you would actually see that working in the dev environment so that's the technical side you have the instant feedback to figure out if you have to move on or you know if you have to make some changes to the code that you have right now now that's crumb and agile in general then there is a second method so scrum was one of the philosophies or framework then you have something called as extreme programming now this was one of the first ones a group of developers came up with it back in 2001. So they kind of came up with the idea of agile development they came up with a set of best practices and then they even signed a manifest so they actually came up with a manifest that you know these are the things that we should be following in the industry these are the best practices and these are the principles and they even signed it so extreme programming has been around for almost a couple of decades and scrum is kind of the next iteration of extreme programming it's a big different So you could call it a framework you could call it a philosophy or methodology now it really depends on you know the word that you want to use but at the end of the day it's again trying to become a developer centric and people centric and setting best practices to make sure everyone in the team knows exactly what they're supposed to do and you have a cross-functional team when i say cross-functional essentially i'm pretty sure if you're watching this video is because you have some of the other development experience and if you do then you would have come across this point right when you talk to someone okay you've seen that feature and we looked at the code and that guy would be like you know that code doesn't concern me it's none of my concern i'm working on something completely different you know we are used to that sort of development right where people individually know what they're supposed to do and they're not even worried about what the other person is doing now it's time we actually break the silos just because you're not coding that part it does not mean that the code does not concern the part of the code that you are writing so everybody has to come together and work on the same application which is what you'll call a cross-functional team in the scrum example once you have the user stories and the backlogs that you are supposed to work on in the next two weeks it doesn't really matter what role do you play in the team it's your team's responsibility to make sure that the task has been completed and the task is also being designed with the timeline in mind. Meeting for example you developed 20% of the application and your end user or your client came back with a better idea or if they need some modifications so those are the changes then you have your unt testing you have client side duty testing and acceptance at the end of it so extreme programming the ideas are somewhat similar to scrum but at the end of the day all of these philosophies are trying to make the lives of developers the end users better and not compromising on technicalities rather making the shippable product better and faster is the idea all right let's move on then you have lean programming so lean principles even this has been around for a while so eliminate waste amplify learning decide as late as possible decide as fast as possible empower the team build integrity and see the whole Now i'm pretty sure all of us or at least most of us are aware about netflix now you would be surprised to know that netflix is pushing more than 1,000 changes every day into their productions if you actually worked at a netflix development team you would know that these guys are pushing a thousand changes in production every day now how do you think that's possible obviously they are not pushing it to production without reviewing it so without testing it even with all of those things in place how are they able to deploy more than 1,000 changes every day now these could be very little changes like you know some ui fixes some database fixes some payment process and fixes so we are not really concerned about what the changes are but i know for a fact that that's the number that's the amount of changes that they actually push every day that's possible because you mean the rapid deployment by agility or by becoming a jar so that's the level of agility you can actually obtain the moment you have an organized team that is working on the principles of a jar now obviously there are external factors like you know how's your infrastructure. So these are the ideas of a job now i hope i was cleared into how can i shall help your team in becoming a better development team so there are three aspects of it right philosophical technical and the way software is built so philosophical being the best practices like how do you define your team's who is a scrum master who's a product owner what's the team what is a sprint what are the tasks that you're supposed to do then you have the technical side of it like if you build a code how exactly can you deploy the code like automatically how can you review the code how can you test the code automatically and then there is a software development aspect of it that you are moving away from a monolithic application towards the idea of micro services so these are the three aspects that move parallely and at the end of the day it gives you a peace of mind it gives your product manager a peace of mind and the end user a peace of mind with better ideas of deployment so that you don't really have to run around on 10 different desks confirming if your changes are actually deployed or not so that's everything from me if you have any questions feel free to get in touch with ed eureka i'm pretty sure you'll find the contact details somewhere around this video and thank you very much for your time you all have a good day and. Parts so if your job is to build this and let's say your colleague drove this protest this the moment you push this first item into the testing you another item will replace this first item so that you know what is the next thing that you are supposed to be working on so kanban is more like a continuous implementation of the software development so that's what you mean by agility in general even if you think about it the english word agility means to be really rapid right agility would mean whatever you're doing is happening in rapid succession .